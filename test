package org.finra.cpu.rmdownload.service;

import org.apache.commons.io.IOUtils;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class CommandTest {

    private MockedStatic<LoggerFactory> mockedLoggerFactory;
    private Logger mockLogger;

    @BeforeEach
    public void setUp() {
        // Mocking the logger to intercept log messages
        mockLogger = mock(Logger.class);
        mockedLoggerFactory = mockStatic(LoggerFactory.class);
        mockedLoggerFactory.when(() -> LoggerFactory.getLogger(Command.class)).thenReturn(mockLogger);
    }

    @Test
    public void testRunCommandSuccess() throws IOException, InterruptedException {
        // Arrange
        Process mockProcess = mock(Process.class);
        ProcessBuilder mockProcessBuilder = mock(ProcessBuilder.class);
        String processOutput = "Command executed successfully.";
        ByteArrayInputStream inputStream = new ByteArrayInputStream(processOutput.getBytes(StandardCharsets.UTF_8));

        // Mocking ProcessBuilder and Process
        try (MockedStatic<ProcessBuilder> mockedProcessBuilderStatic = mockStatic(ProcessBuilder.class)) {
            mockedProcessBuilderStatic.when(() -> new ProcessBuilder(anyList())).thenReturn(mockProcessBuilder);
            when(mockProcessBuilder.redirectErrorStream(true)).thenReturn(mockProcessBuilder);
            when(mockProcessBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE)).thenReturn(mockProcessBuilder);
            when(mockProcessBuilder.start()).thenReturn(mockProcess);

            when(mockProcess.getInputStream()).thenReturn(inputStream);
            when(mockProcess.waitFor()).thenReturn(0);

            // Act
            int exitCode = Command.runCommand(List.of("echo", "Hello"), "TestProcess");

            // Assert
            assertEquals(0, exitCode);
            verify(mockLogger).info(processOutput.trim());
            verify(mockLogger).info("TestProcess exited with code 0");
        }
    }

    @Test
    public void testRunCommandFailure() throws IOException, InterruptedException {
        // Arrange
        Process mockProcess = mock(Process.class);
        ProcessBuilder mockProcessBuilder = mock(ProcessBuilder.class);
        String processOutput = "Command failed.";
        ByteArrayInputStream inputStream = new ByteArrayInputStream(processOutput.getBytes(StandardCharsets.UTF_8));

        // Mocking ProcessBuilder and Process
        try (MockedStatic<ProcessBuilder> mockedProcessBuilderStatic = mockStatic(ProcessBuilder.class)) {
            mockedProcessBuilderStatic.when(() -> new ProcessBuilder(anyList())).thenReturn(mockProcessBuilder);
            when(mockProcessBuilder.redirectErrorStream(true)).thenReturn(mockProcessBuilder);
            when(mockProcessBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE)).thenReturn(mockProcessBuilder);
            when(mockProcessBuilder.start()).thenReturn(mockProcess);

            when(mockProcess.getInputStream()).thenReturn(inputStream);
            when(mockProcess.waitFor()).thenReturn(1);

            // Act
            int exitCode = Command.runCommand(List.of("nonexistent-command"), "FailingProcess");

            // Assert
            assertEquals(1, exitCode);
            verify(mockLogger).info(processOutput.trim());
            verify(mockLogger).info("FailingProcess exited with code 1");
        }
    }

    @Test
    public void testPrintOutput() throws IOException {
        // Arrange
        String processOutput = "Some process output.";
        ByteArrayInputStream inputStream = new ByteArrayInputStream(processOutput.getBytes(StandardCharsets.UTF_8));
        Process mockProcess = mock(Process.class);
        when(mockProcess.getInputStream()).thenReturn(inputStream);

        // Act
        Command.printOutput(mockProcess);

        // Assert
        verify(mockLogger).info(processOutput.trim());
    }

    @Test
    public void testPrintOutputEmpty() throws IOException {
        // Arrange
        ByteArrayInputStream inputStream = new ByteArrayInputStream("".getBytes(StandardCharsets.UTF_8));
        Process mockProcess = mock(Process.class);
        when(mockProcess.getInputStream()).thenReturn(inputStream);

        // Act
        Command.printOutput(mockProcess);

        // Assert
        verify(mockLogger, never()).info(anyString());
    }

    @Test
    public void testPrintExitCode() {
        // Act
        Command.printExitCode("TestProcess", 0);

        // Assert
        verify(mockLogger).info("TestProcess exited with code 0");
    }
}